

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/HttpServer.java ===

package com.microtomcat;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import com.microtomcat.server.ServerConfig;
import com.microtomcat.server.AbstractHttpServer;
import com.microtomcat.server.HttpServerFactory;
import com.microtomcat.loader.ClassLoaderManager;
import com.microtomcat.processor.ProcessorPool;
import com.microtomcat.lifecycle.LifecycleException;
import com.microtomcat.connector.Connector;
import com.microtomcat.container.Engine;
import com.microtomcat.container.Host;
import com.microtomcat.context.Context;
import com.microtomcat.jmx.MBeanRegistry;
import com.microtomcat.jmx.StandardServer;
import javax.management.JMException;
import javax.management.StandardMBean;

public class HttpServer extends AbstractHttpServer {
    private static final int DEFAULT_PORT = 8080;
    private final int port;
    private static final String WEB_ROOT = "webroot";
    private final ExecutorService executorService;
    private MBeanRegistry mbeanRegistry;
    private StandardServer serverMBean;
    private Connector connector;
    private Engine engine;
    private ProcessorPool processorPool;

    public HttpServer(int port) throws IOException {
        super(new ServerConfig(port, false, 10, WEB_ROOT));
        this.port = port;
        this.executorService = Executors.newFixedThreadPool(10);
        
        // 按正确顺序初始化组件
        this.engine = new Engine("MicroTomcat", "localhost");
        
        Host defaultHost = new Host("localhost");
        engine.addChild(defaultHost);
        
        try {
            Context rootContext = new Context("", WEB_ROOT);
            defaultHost.addChild(rootContext);
            
            Context app1Context = new Context("/app1", WEB_ROOT + "/app1");
            Context app2Context = new Context("/app2", WEB_ROOT + "/app2");
            defaultHost.addChild(app1Context);
            defaultHost.addChild(app2Context);
            
            this.processorPool = new ProcessorPool(100, WEB_ROOT, engine);
            this.connector = new Connector(port, processorPool);
            
            engine.init();
            processorPool.init();
            connector.init();
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to initialize server", e);
        }
    }

    @Override
    protected void log(String message) {
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_TIME);
        System.out.printf("[%s] %s%n", timestamp, message);
    }

    @Override
    public void start() throws LifecycleException {
        try {
            // 初始化类加载器
            ClassLoaderManager.init();
            
            // 启动各个组件
            engine.start();
            processorPool.start();
            connector.start();  // Connector 会处理所有的连接接收和处理
            
            log("Server started on port: " + port);
            
            // 等待服务器运行
            while (true) {
                try {
                    Thread.sleep(Long.MAX_VALUE);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        } catch (Exception e) {
            throw new LifecycleException("Failed to start server", e);
        }
    }

    private void handleRequest(Socket socket) throws IOException {
        try (InputStream input = socket.getInputStream();
             OutputStream output = socket.getOutputStream();
             BufferedReader reader = new BufferedReader(new InputStreamReader(input))) {

            // 读取请求行
            String requestLine = reader.readLine();
            if (requestLine == null) {
                return;
            }

            // 解析URI
            String[] parts = requestLine.split(" ");
            if (parts.length != 3) {
                return;
            }
            String uri = parts[1];
            log("Received request for URI: " + uri);

            // 读取文件
            Path filePath = Paths.get(WEB_ROOT, uri);
            if (Files.exists(filePath)) {
                // 发送响应头
                String contentType = getContentType(uri);
                byte[] fileContent = Files.readAllBytes(filePath);
                
                output.write("HTTP/1.1 200 OK\r\n".getBytes());
                output.write(("Content-Type: " + contentType + "\r\n").getBytes());
                output.write(("Content-Length: " + fileContent.length + "\r\n").getBytes());
                output.write("\r\n".getBytes());
                
                // 发送文件内容
                output.write(fileContent);
                output.flush();
                
                log("Successfully served file: " + uri);
            } else {
                // 文件不存在，返回404
                String errorMessage = "404 File Not Found";
                output.write("HTTP/1.1 404 Not Found\r\n".getBytes());
                output.write("Content-Type: text/plain\r\n".getBytes());
                output.write(("Content-Length: " + errorMessage.length() + "\r\n").getBytes());
                output.write("\r\n".getBytes());
                output.write(errorMessage.getBytes());
                output.flush();
                
                log("File not found: " + uri);
            }
        }
    }

    private String getContentType(String uri) {
        if (uri.endsWith(".html")) {
            return "text/html";
        } else if (uri.endsWith(".txt")) {
            return "text/plain";
        } else if (uri.endsWith(".css")) {
            return "text/css";
        } else if (uri.endsWith(".js")) {
            return "application/javascript";
        }
        return "application/octet-stream";
    }

    @Override
    protected void initInternal() throws LifecycleException {
        super.initInternal();
        
        try {
            System.out.println("Initializing JMX support...");
            mbeanRegistry = new MBeanRegistry();
            
            System.out.println("Registering Server MBean...");
            serverMBean = new StandardServer(processorPool, engine);
            mbeanRegistry.registerMBean(serverMBean, "Server");
            
            System.out.println("Registering ProcessorPool MBean...");
            mbeanRegistry.registerMBean(processorPool, "ProcessorPool");
            
            System.out.println("Registering Connector MBean...");
            mbeanRegistry.registerMBean(connector, "Connector");
            
            System.out.println("JMX initialization completed.");
        } catch (JMException e) {
            throw new LifecycleException("Failed to initialize JMX support", e);
        }
    }
    
    @Override
    protected void destroyInternal() throws LifecycleException {
        // 注销所有 MBean
        try {
            if (mbeanRegistry != null) {
                mbeanRegistry.unregisterMBean("Server");
                mbeanRegistry.unregisterMBean("ProcessorPool");
                mbeanRegistry.unregisterMBean("Connector");
            }
        } catch (JMException e) {
            throw new LifecycleException("Failed to cleanup JMX support", e);
        }
        super.destroyInternal();
    }

    public static void main(String[] args) {
        try {
            ServerConfig config = new ServerConfig(
                DEFAULT_PORT,    // 端口
                false,          // 使用阻塞式 IO
                10,            // 线程池大小
                WEB_ROOT       // Web根目录
            );
            
            AbstractHttpServer server = HttpServerFactory.createServer(config);
            server.init();
            server.start();
        } catch (IOException | LifecycleException e) {
            System.err.println("Server startup failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    @Override
    public void stop() throws LifecycleException {
        // 关闭线程池
        if (executorService != null && !executorService.isShutdown()) {
            executorService.shutdown();
            try {
                if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) {
                    executorService.shutdownNow();
                }
            } catch (InterruptedException e) {
                executorService.shutdownNow();
                Thread.currentThread().interrupt();
                throw new LifecycleException("Error while stopping server", e);
            }
        }
        log("Server stopped");
    }
}


=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/connector/Connector.java ===

package com.microtomcat.connector;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import com.microtomcat.processor.ProcessorPool;
import com.microtomcat.lifecycle.LifecycleBase;
import com.microtomcat.lifecycle.LifecycleException;
import javax.management.StandardMBean;

public class Connector extends LifecycleBase implements Runnable, ConnectorMBean {
    private final ServerSocket serverSocket;
    private final ProcessorPool processorPool;
    private volatile boolean running = true;
    private final BlockingQueue<Socket> connectionQueue;
    private final Object lock = new Object();
    private final ExecutorService executorService;
    private final AtomicInteger activeConnections = new AtomicInteger(0);
    private final AtomicLong totalRequests = new AtomicLong(0);
    private final AtomicLong totalProcessingTime = new AtomicLong(0);
    private int connectionTimeout = 20000; // 默认20秒
    
    public Connector(int port, ProcessorPool processorPool) throws IOException {
        this.serverSocket = new ServerSocket(port);
        this.processorPool = processorPool;
        this.connectionQueue = new ArrayBlockingQueue<>(200);
        this.executorService = processorPool.getExecutor();
    }
    
    @Override
    protected void initInternal() throws LifecycleException {
        log("Initializing Connector on port: " + serverSocket.getLocalPort());
        if (serverSocket == null || serverSocket.isClosed()) {
            throw new LifecycleException("Server socket not initialized or closed");
        }
    }
    
    @Override
    protected void startInternal() throws LifecycleException {
        log("Starting Connector");
        running = true;
        
        // 启动工作线程处理连接队列
        Thread worker = new Thread(() -> {
            while (running) {
                try {
                    Socket socket = serverSocket.accept();
                    processSocket(socket);
                } catch (IOException e) {
                    if (running) {
                        log("Error accepting connection: " + e.getMessage());
                    }
                }
            }
        }, "Connector-Worker");
        worker.start();
    }
    
    @Override
    protected void stopInternal() throws LifecycleException {
        log("Stopping Connector");
        running = false;
        try {
            // 清理连接队列
            connectionQueue.clear();
            // 关闭服务器套接字
            if (!serverSocket.isClosed()) {
                serverSocket.close();
            }
        } catch (IOException e) {
            throw new LifecycleException("Failed to stop connector", e);
        }
    }
    
    @Override
    protected void destroyInternal() throws LifecycleException {
        log("Destroying Connector");
        try {
            if (!serverSocket.isClosed()) {
                serverSocket.close();
            }
        } catch (IOException e) {
            throw new LifecycleException("Failed to destroy connector", e);
        }
    }
    
    private void log(String message) {
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        System.out.printf("[%s] [Connector] %s%n", timestamp, message);
    }
    
    @Override
    public void run() {
       // 不知道为什么不需要实现
    }

    public void processSocket(Socket socket) {
        synchronized(lock) {
            while (connectionQueue.remainingCapacity() == 0) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return;
                }
            }
            connectionQueue.offer(socket);
            lock.notifyAll();
        }
    }
    
    public Socket getSocket() {
        synchronized(lock) {
            while (connectionQueue.isEmpty()) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return null;
                }
            }
            Socket socket = connectionQueue.poll();
            lock.notifyAll();
            return socket;
        }
    }
    
    @Override
    public boolean isRunning() {
        return running;
    }
    
    @Override
    public int getCurrentThreadCount() {
        return ((ThreadPoolExecutor) executorService).getActiveCount();
    }
    
    @Override
    public int getActiveConnections() {
        return activeConnections.get();
    }
    
    @Override
    public long getTotalRequests() {
        return totalRequests.get();
    }
    
    @Override
    public double getAverageResponseTime() {
        long requests = totalRequests.get();
        return requests > 0 ? (double) totalProcessingTime.get() / requests : 0;
    }
    
    @Override
    public void setMaxThreads(int maxThreads) {
        if (executorService instanceof ThreadPoolExecutor) {
            ((ThreadPoolExecutor) executorService).setMaximumPoolSize(maxThreads);
        }
    }
    
    @Override
    public void setConnectionTimeout(int timeout) {
        this.connectionTimeout = timeout;
    }
}

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/connector/ConnectorMBean.java ===

package com.microtomcat.connector;

/**
 * Connector的JMX管理接口
 * 提供连接器的监控和管理功能
 */
public interface ConnectorMBean {
    /**
     * 获取连接器运行状态
     */
    boolean isRunning();
    
    /**
     * 获取当前活动线程数
     */
    int getCurrentThreadCount();
    
    /**
     * 获取当前活动连接数
     */
    int getActiveConnections();
    
    /**
     * 获取已处理的总请求数
     */
    long getTotalRequests();
    
    /**
     * 获取请求的平均响应时间（毫秒）
     */
    double getAverageResponseTime();
    
    /**
     * 设置工作线程池的最大线程数
     * @param maxThreads 最大线程数
     */
    void setMaxThreads(int maxThreads);
    
    /**
     * 设置连接超时时间
     * @param timeout 超时时间（毫秒）
     */
    void setConnectionTimeout(int timeout);
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/jmx/ConnectorMBean.java ===

package com.microtomcat.jmx;

/**
 * Connector的JMX管理接口
 * 提供连接器的监控和管理功能
 */
public interface ConnectorMBean {
    /**
     * 获取连接器运行状态
     */
    boolean isRunning();
    
    /**
     * 获取当前活动线程数
     */
    int getCurrentThreadCount();
    
    /**
     * 获取当前活动连接数
     */
    int getActiveConnections();
    
    /**
     * 获取已处理的总请求数
     */
    long getTotalRequests();
    
    /**
     * 获取请求的平均响应时间（毫秒）
     */
    double getAverageResponseTime();
    
    /**
     * 设置工作线程池的最大线程数
     * @param maxThreads 最大线程数
     */
    void setMaxThreads(int maxThreads);
    
    /**
     * 设置连接超时时间
     * @param timeout 超时时间（毫秒）
     */
    void setConnectionTimeout(int timeout);
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/jmx/ProcessorPoolMBean.java ===

package com.microtomcat.jmx;

/**
 * ProcessorPool的JMX管理接口
 */
public interface ProcessorPoolMBean {
    // 处理器池状态
    int getActiveProcessors();
    int getIdleProcessors();
    
    // 性能指标
    long getTotalProcessedRequests();
    double getAverageProcessingTime();
    
    // 操作
    void setMaxProcessors(int max);
    void invalidateAllSessions();
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/processor/ProcessorPool.java ===

package com.microtomcat.processor;

import com.microtomcat.servlet.ServletLoader;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import com.microtomcat.session.SessionManager;
import com.microtomcat.context.Context;
import com.microtomcat.context.ContextManager;
import com.microtomcat.processor.ProcessorPoolMBean;

import java.io.IOException;
import com.microtomcat.lifecycle.LifecycleBase;
import com.microtomcat.lifecycle.LifecycleException;
import com.microtomcat.container.Container;
import com.microtomcat.container.Engine;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ThreadPoolExecutor;

public class ProcessorPool extends LifecycleBase implements ProcessorPoolMBean {
    private final BlockingQueue<Processor> pool;
    private final List<Processor> allProcessors;
    private final int maxProcessors;
    private final String webRoot;
    private final Engine engine;
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition notEmpty = lock.newCondition();
    private final Condition notFull = lock.newCondition();
    private final AtomicInteger activeProcessors = new AtomicInteger(0);
    private final AtomicLong totalProcessingTime = new AtomicLong(0);
    private final AtomicLong requestCount = new AtomicLong(0);
    private final AtomicInteger currentLoad = new AtomicInteger(0);
    private final AtomicLong totalRequests = new AtomicLong(0);
    private final ExecutorService executorService;

    public ProcessorPool(int maxProcessors, String webRoot, Engine engine) {
        this.maxProcessors = maxProcessors;
        this.webRoot = webRoot;
        this.engine = engine;
        this.pool = new ArrayBlockingQueue<>(maxProcessors);
        this.allProcessors = new ArrayList<>();
        
        // 预创建处理器
        int initialProcessors = Math.min(maxProcessors / 2, 10);
        for (int i = 0; i < initialProcessors; i++) {
            createProcessor();
        }
        
        this.executorService = new ThreadPoolExecutor(
            1,                      // 核心线程数
            maxProcessors,            // 最大线程数
            60L,                   // 空闲线程存活时间
            TimeUnit.SECONDS,      // 时间单位
            new ArrayBlockingQueue<>(100)  // 工作队列
        );
    }

    @Override
    protected void initInternal() throws LifecycleException {
        log("Initializing ProcessorPool with " + allProcessors.size() + " processors");
        for (Processor processor : allProcessors) {
            processor.init();
        }
    }

    @Override
    protected void startInternal() throws LifecycleException {
        log("Starting ProcessorPool");
        for (Processor processor : allProcessors) {
            processor.start();
        }
    }

    @Override
    protected void stopInternal() throws LifecycleException {
        log("Stopping ProcessorPool");
        for (Processor processor : allProcessors) {
            processor.stop();
        }
    }

    @Override
    protected void destroyInternal() throws LifecycleException {
        log("Destroying ProcessorPool");
        for (Processor processor : allProcessors) {
            processor.destroy();
        }
        pool.clear();
        allProcessors.clear();
    }

    private void log(String message) {
        System.out.println("[ProcessorPool] " + message);
    }

    public Processor getProcessor(long timeout) throws InterruptedException {
        lock.lock();
        try {
            long nanos = TimeUnit.MILLISECONDS.toNanos(timeout);
            while (pool.isEmpty() && nanos > 0) {
                nanos = notEmpty.awaitNanos(nanos);
            }
            Processor processor = pool.poll();
            if (processor != null) {
                notFull.signal();
            }
            return processor;
        } finally {
            lock.unlock();
        }
    }

    public void releaseProcessor(Processor processor) {
        lock.lock();
        try {
            pool.offer(processor);
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    private void createProcessor() {
        Processor processor = new Processor(webRoot, engine);
        allProcessors.add(processor);
        pool.offer(processor);
    }

    public int getActiveCount() {
        return allProcessors.size() - pool.size();
    }

    public int getTotalCount() {
        return allProcessors.size();
    }

    public void recordProcessingTime(long processingTimeMs) {
        totalProcessingTime.addAndGet(processingTimeMs);
        requestCount.incrementAndGet();
    }

    @Override
    public double getAverageProcessingTime() {
        long count = requestCount.get();
        return count > 0 ? (double) totalProcessingTime.get() / count : 0;
    }

    public int getCurrentLoad() {
        return currentLoad.get();
    }

    public void recordRequest(long processingTimeMs) {
        totalRequests.incrementAndGet();
        totalProcessingTime.addAndGet(processingTimeMs);
    }

    public long getRequestCount() {
        return totalRequests.get();
    }

    protected void incrementLoad() {
        currentLoad.incrementAndGet();
    }

    protected void decrementLoad() {
        currentLoad.decrementAndGet();
    }

    @Override
    public int getActiveProcessors() {
        return getActiveCount();
    }
    
    @Override
    public int getIdleProcessors() {
        return pool.size();
    }
    
    @Override
    public long getTotalProcessedRequests() {
        return getRequestCount();
    }
    
    @Override
    public void setMaxProcessors(int max) {
        // 动态调整处理器池大小
        lock.lock();
        try {
            while (allProcessors.size() < max) {
                createProcessor();
            }
        } finally {
            lock.unlock();
        }
    }
    
    @Override
    public void invalidateAllSessions() {
        // 遍历所有 Context 并使其 Session 失效
        for (Container child : engine.findChildren()) {
            if (child instanceof Context) {
                Context context = (Context) child;
                context.getSessionManager().invalidateAll();
            }
        }
    }

    public ExecutorService getExecutor() {
        return executorService;
    }
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/processor/ProcessorPoolMBean.java ===

package com.microtomcat.processor;

/**
 * ProcessorPool的JMX管理接口
 */
public interface ProcessorPoolMBean {
    // 处理器池状态
    int getActiveProcessors();
    int getIdleProcessors();
    
    // 性能指标
    long getTotalProcessedRequests();
    double getAverageProcessingTime();
    
    // 操作
    void setMaxProcessors(int max);
    void invalidateAllSessions();
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/server/AbstractHttpServer.java ===

package com.microtomcat.server;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import com.microtomcat.container.Engine;
import com.microtomcat.lifecycle.LifecycleException;
import com.microtomcat.processor.ProcessorPool;

public abstract class AbstractHttpServer {
    protected final ServerConfig config;
    protected static final String WEB_ROOT = "webroot";
    protected ProcessorPool processorPool;
    protected Engine engine;
    
    protected AbstractHttpServer(ServerConfig config) {
        this.config = config;
    }
    
    public abstract void start() throws LifecycleException;
    public abstract void stop() throws LifecycleException;
    
    protected void log(String message) {
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_TIME);
        System.out.printf("[%s] %s%n", timestamp, message);
    }
    
    protected void initInternal() throws LifecycleException {
        // 基础初始化逻辑
    }
    
    protected void destroyInternal() throws LifecycleException {
        // 基础销毁逻辑
    }
    
    public void init() throws LifecycleException {
        initInternal();
    }
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/server/BlockingHttpServer.java ===

package com.microtomcat.server;

import com.microtomcat.connector.Connector;
import com.microtomcat.processor.Processor;
import com.microtomcat.processor.ProcessorPool;
import com.microtomcat.servlet.ServletLoader;
import com.microtomcat.session.SessionManager;
import com.microtomcat.context.Context;
import com.microtomcat.container.Engine;
import com.microtomcat.container.Host;
import com.microtomcat.lifecycle.LifecycleException;
import com.microtomcat.jmx.MBeanRegistry;
import com.microtomcat.jmx.StandardServer;
import javax.management.JMException;

import java.io.*;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class BlockingHttpServer extends AbstractHttpServer {
    private final ExecutorService executorService;
    private final ProcessorPool processorPool;
    private final Connector connector;
    private final Engine engine;
    private volatile boolean running = true;
    private MBeanRegistry mbeanRegistry;
    private StandardServer serverMBean;

    public BlockingHttpServer(ServerConfig config) {
        super(config);
        this.executorService = Executors.newFixedThreadPool(config.getThreadPoolSize());
        
        this.engine = new Engine("MicroTomcat", "localhost");
        
        Host defaultHost = new Host("localhost");
        engine.addChild(defaultHost);
        
        try {
            Context rootContext = new Context("", config.getWebRoot());
            defaultHost.addChild(rootContext);
            
            Context app1Context = new Context("/app1", config.getWebRoot() + "/app1");
            Context app2Context = new Context("/app2", config.getWebRoot() + "/app2");
            defaultHost.addChild(app1Context);
            defaultHost.addChild(app2Context);
            
            this.processorPool = new ProcessorPool(
                100,
                config.getWebRoot(),
                engine
            );
            
            this.connector = new Connector(config.getPort(), processorPool);
            
            engine.init();
            processorPool.init();
            connector.init();
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to initialize server", e);
        }
    }

    @Override
    public void start() {
        try {
            engine.start();
            processorPool.start();
            connector.start();
            
            for (int i = 0; i < config.getThreadPoolSize(); i++) {
                executorService.submit(new ConnectionHandler());
            }
            
            log("Server started on port " + config.getPort());
            
            synchronized (this) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        } catch (LifecycleException  e) {
            throw new RuntimeException("Failed to start server", e);
        }
    }

    private class ConnectionHandler implements Runnable {
        @Override
        public void run() {
            while (running) {
                Socket socket = connector.getSocket();
                if (socket != null) {
                    handleRequest(socket);
                }
            }
        }
    }

    private void handleRequest(Socket socket) {
        Processor processor = null;
        try {
            processor = processorPool.getProcessor(5000); // 5秒超时
            if (processor != null) {
                log(String.format("Acquired processor (active/total: %d/%d) for request from: %s",
                    processorPool.getActiveCount(),
                    processorPool.getTotalCount(),
                    socket.getInetAddress()));
                processor.process(socket);
            } else {
                log("No processor available, sending 503 response to: " + socket.getInetAddress());
                try (OutputStream output = socket.getOutputStream()) {
                    String response = "HTTP/1.1 503 Service Unavailable\r\n" +
                            "Content-Type: text/plain\r\n" +
                            "Content-Length: 35\r\n" +
                            "\r\n" +
                            "Server is too busy, please try later.";
                    output.write(response.getBytes());
                }
            }
        } catch (InterruptedException e) {
            log("Processor acquisition interrupted for " + socket.getInetAddress() + ": " + e.getMessage());
        } catch (IOException e) {
            log("Error processing request from " + socket.getInetAddress() + ": " + e.getMessage());
        } finally {
            if (processor != null) {
                processorPool.releaseProcessor(processor);
                log("Released processor back to pool");
            }
            try {
                socket.close();
            } catch (IOException e) {
                log("Error closing socket for " + socket.getInetAddress() + ": " + e.getMessage());
            }
        }
    }

    @Override
    public void stop() {
        running = false;
        try {
            connector.stop();
            processorPool.stop();
            engine.stop();
            executorService.shutdown();
        } catch (Exception e) {
            log("Error while stopping server: " + e.getMessage());
        }
    }

    @Override
    protected void initInternal() throws LifecycleException {
        super.initInternal();
        
        try {
            System.out.println("Initializing JMX support...");
            mbeanRegistry = new MBeanRegistry();
            
            System.out.println("Registering Server MBean...");
            serverMBean = new StandardServer(processorPool, engine);
            mbeanRegistry.registerMBean(serverMBean, "Server");
            
            System.out.println("Registering ProcessorPool MBean...");
            mbeanRegistry.registerMBean(processorPool, "ProcessorPool");
            
            System.out.println("Registering Connector MBean...");
            mbeanRegistry.registerMBean(connector, "Connector");
            
            System.out.println("JMX initialization completed.");
        } catch (JMException e) {
            throw new LifecycleException("Failed to initialize JMX support", e);
        }
    }
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/server/HttpServerFactory.java ===

package com.microtomcat.server;

import java.io.IOException;

import com.microtomcat.HttpServer;

public class HttpServerFactory {
    public static AbstractHttpServer createServer(ServerConfig config) throws IOException {
        return new HttpServer(config.getPort());
    }
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/server/NonBlockingHttpServer.java ===

package com.microtomcat.server;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

import com.microtomcat.lifecycle.LifecycleException;

public class NonBlockingHttpServer extends AbstractHttpServer {
    private final Selector selector;
    private final ServerSocketChannel serverChannel;

    public NonBlockingHttpServer(ServerConfig config) throws IOException {
        super(config);
        this.selector = Selector.open();
        this.serverChannel = ServerSocketChannel.open();
        this.serverChannel.configureBlocking(false);
        this.serverChannel.socket().bind(new InetSocketAddress(config.getPort()));
        this.serverChannel.register(selector, SelectionKey.OP_ACCEPT);
    }

    @Override
    public void start() throws LifecycleException {
        try {
            log("Non-blocking server started on port: " + config.getPort());
            
            while (!Thread.currentThread().isInterrupted()) {
                selector.select();
                Set<SelectionKey> selectedKeys = selector.selectedKeys();
                Iterator<SelectionKey> iter = selectedKeys.iterator();

                while (iter.hasNext()) {
                    SelectionKey key = iter.next();
                    iter.remove();

                    if (key.isAcceptable()) {
                        SocketChannel client = serverChannel.accept();
                        client.configureBlocking(false);
                        client.register(selector, SelectionKey.OP_READ);
                        log("New connection accepted from: " + client.getRemoteAddress());
                    } else if (key.isReadable()) {
                        handleRead(key);
                    }
                }
            }
        } catch (IOException e) {
            throw new LifecycleException("Error starting server: " + e.getMessage(), e);
        }
    }

    @Override
    public void stop() {
        try {
            selector.close();
            serverChannel.close();
        } catch (IOException e) {
            log("Error while stopping server: " + e.getMessage());
        }
    }
    
    private void handleRead(SelectionKey key) throws IOException {
        SocketChannel client = (SocketChannel) key.channel();
        try {
            // 创建缓冲区读取数据
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            int bytesRead = client.read(buffer);
            
            if (bytesRead == -1) {
                // 客户端关闭连接
                key.cancel();
                client.close();
                return;
            }
            
            // 处理HTTP请求
            buffer.flip();
            byte[] data = new byte[buffer.remaining()];
            buffer.get(data);
            String request = new String(data);
            
            // 发送响应
            String response = "HTTP/1.1 200 OK\r\n" +
                            "Content-Type: text/plain\r\n" +
                            "Content-Length: 13\r\n" +
                            "\r\n" +
                            "Hello, World!";
            
            ByteBuffer responseBuffer = ByteBuffer.wrap(response.getBytes());
            client.write(responseBuffer);
            
            // 关闭连接
            key.cancel();
            client.close();
            
        } catch (IOException e) {
            log("Error processing request: " + e.getMessage());
            key.cancel();
            client.close();
        }
    }
} 