

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/HttpServer.java ===

package com.microtomcat;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import com.microtomcat.server.ServerConfig;
import com.microtomcat.server.AbstractHttpServer;
import com.microtomcat.server.HttpServerFactory;
import com.microtomcat.loader.ClassLoaderManager;
import com.microtomcat.lifecycle.LifecycleException;

public class HttpServer extends AbstractHttpServer {
    private static final int DEFAULT_PORT = 8080;
    private final int port;
    private static final String WEB_ROOT = "webroot";
    private final ExecutorService executorService;

    public HttpServer(int port) throws IOException {
        super(new ServerConfig(port, false, 10, WEB_ROOT));
        this.port = port;
        this.executorService = Executors.newFixedThreadPool(10);
    }

    @Override
    protected void log(String message) {
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_TIME);
        System.out.printf("[%s] %s%n", timestamp, message);
    }

    @Override
    public void start() throws LifecycleException {
        try {
            // 初始化类加载器
            ClassLoaderManager.init();
            
            try (ServerSocket serverSocket = new ServerSocket(port)) {
                log("Server started on port: " + port);
                while (!Thread.currentThread().isInterrupted()) {
                    Socket socket = serverSocket.accept();
                    log("New connection accepted from: " + socket.getInetAddress());
                    executorService.execute(() -> {
                        try {
                            handleRequest(socket);
                        } catch (Exception e) {
                            log("Error processing request: " + e.getMessage());
                        } finally {
                            try {
                                socket.close();
                            } catch (IOException e) {
                                log("Error closing socket: " + e.getMessage());
                            }
                        }
                    });
                }
            }
        } catch (Exception e) {
            throw new LifecycleException("Failed to start server", e);
        }
    }

    private void handleRequest(Socket socket) throws IOException {
        try (InputStream input = socket.getInputStream();
             OutputStream output = socket.getOutputStream();
             BufferedReader reader = new BufferedReader(new InputStreamReader(input))) {

            // 读取请求行
            String requestLine = reader.readLine();
            if (requestLine == null) {
                return;
            }

            // 解析URI
            String[] parts = requestLine.split(" ");
            if (parts.length != 3) {
                return;
            }
            String uri = parts[1];
            log("Received request for URI: " + uri);

            // 读取文件
            Path filePath = Paths.get(WEB_ROOT, uri);
            if (Files.exists(filePath)) {
                // 发送响应头
                String contentType = getContentType(uri);
                byte[] fileContent = Files.readAllBytes(filePath);
                
                output.write("HTTP/1.1 200 OK\r\n".getBytes());
                output.write(("Content-Type: " + contentType + "\r\n").getBytes());
                output.write(("Content-Length: " + fileContent.length + "\r\n").getBytes());
                output.write("\r\n".getBytes());
                
                // 发送文件内容
                output.write(fileContent);
                output.flush();
                
                log("Successfully served file: " + uri);
            } else {
                // 文件不存在，返回404
                String errorMessage = "404 File Not Found: " + uri;
                output.write("HTTP/1.1 404 Not Found\r\n".getBytes());
                output.write("Content-Type: text/plain\r\n".getBytes());
                output.write(("Content-Length: " + errorMessage.length() + "\r\n").getBytes());
                output.write("\r\n".getBytes());
                output.write(errorMessage.getBytes());
                output.flush();
                
                log("File not found: " + uri);
            }
        }
    }

    private String getContentType(String uri) {
        if (uri.endsWith(".html")) {
            return "text/html";
        } else if (uri.endsWith(".txt")) {
            return "text/plain";
        } else if (uri.endsWith(".css")) {
            return "text/css";
        } else if (uri.endsWith(".js")) {
            return "application/javascript";
        }
        return "application/octet-stream";
    }

    @Override
    protected void initInternal() throws LifecycleException {
        super.initInternal();
    }
    
    @Override
    protected void destroyInternal() throws LifecycleException {
        super.destroyInternal();
    }

    public static void main(String[] args) {
        // 解析命令行参数
        int port = DEFAULT_PORT; // 默认端口
        
        for (int i = 0; i < args.length; i++) {
            if (args[i].startsWith("--port=")) {
                try {
                    port = Integer.parseInt(args[i].substring("--port=".length()));
                } catch (NumberFormatException e) {
                    System.err.println("Invalid port number: " + args[i]);
                    System.exit(1);
                }
            }
        }

        try {
            ServerConfig config = new ServerConfig(
                port,           // 使用解析的端口
                false,          // 使用阻塞式 IO
                10,            // 线程池大小
                WEB_ROOT       // Web根目录
            );
            
            AbstractHttpServer server = HttpServerFactory.createServer(config);
            server.init();
            server.start();
        } catch (IOException | LifecycleException e) {
            System.err.println("Server startup failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    @Override
    public void stop() throws LifecycleException {
        // 关闭线程池
        if (executorService != null && !executorService.isShutdown()) {
            executorService.shutdown();
            try {
                if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) {
                    executorService.shutdownNow();
                }
            } catch (InterruptedException e) {
                executorService.shutdownNow();
                Thread.currentThread().interrupt();
                throw new LifecycleException("Error while stopping server", e);
            }
        }
        log("Server stopped");
    }
}


=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/cluster/ClusterRegistry.java ===

package com.microtomcat.cluster;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.List;
import java.util.ArrayList;

public class ClusterRegistry {
    private final Map<String, ClusterNode> nodes = new ConcurrentHashMap<>();
    private static final ClusterRegistry instance = new ClusterRegistry();

    private ClusterRegistry() {}

    public static ClusterRegistry getInstance() {
        return instance;
    }

    public void registerNode(ClusterNode node) {
        if (validateNode(node)) {
            nodes.put(node.getId(), node);
            log("Node registered: " + node);
        }
    }

    public void unregisterNode(String nodeId) {
        ClusterNode node = nodes.remove(nodeId);
        if (node != null) {
            log("Node unregistered: " + node);
        }
    }

    public List<ClusterNode> getAllNodes() {
        return new ArrayList<>(nodes.values());
    }

    public ClusterNode getNode(String nodeId) {
        return nodes.get(nodeId);
    }

    private boolean validateNode(ClusterNode node) {
        if (node.getName() == null || node.getName().trim().isEmpty()) {
            log("Invalid node name");
            return false;
        }
        if (node.getHost() == null || node.getHost().trim().isEmpty()) {
            log("Invalid host");
            return false;
        }
        if (node.getPort() <= 0 || node.getPort() > 65535) {
            log("Invalid port number");
            return false;
        }
        return true;
    }

    private void log(String message) {
        System.out.println("[ClusterRegistry] " + message);
    }
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/cluster/NodeStatusManager.java ===

package com.microtomcat.cluster;

import java.util.Collection;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class NodeStatusManager {
    private final Map<String, ClusterNode> nodes = new ConcurrentHashMap<>();
    private final Map<String, NodeStatusListener> listeners = new ConcurrentHashMap<>();

    public void updateNodeStatus(ClusterNode node, NodeStatus newStatus) {
        NodeStatus oldStatus = node.getStatus();
        if (oldStatus != newStatus) {
            node.setStatus(newStatus);
            notifyStatusChange(node, oldStatus, newStatus);
        }
    }

    public void addStatusListener(String listenerId, NodeStatusListener listener) {
        listeners.put(listenerId, listener);
    }

    public void removeStatusListener(String listenerId) {
        listeners.remove(listenerId);
    }

    private void notifyStatusChange(ClusterNode node, NodeStatus oldStatus, NodeStatus newStatus) {
        for (NodeStatusListener listener : listeners.values()) {
            if (oldStatus == NodeStatus.RUNNING && newStatus == NodeStatus.UNREACHABLE) {
                listener.onNodeDown(node);
            } else if (oldStatus == NodeStatus.UNREACHABLE && newStatus == NodeStatus.RUNNING) {
                listener.onNodeUp(node);
            }
        }
    }

    public Collection<ClusterNode> getAllNodes() {
        return nodes.values();
    }

    public void addNode(ClusterNode node) {
        nodes.put(node.getId(), node);
    }

    public void removeNode(String nodeId) {
        nodes.remove(nodeId);
    }
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/cluster/heartbeat/DefaultHeartbeatService.java ===

package com.microtomcat.cluster.heartbeat;

import com.microtomcat.cluster.ClusterNode;
import com.microtomcat.cluster.NodeStatus;
import com.microtomcat.cluster.NodeStatusManager;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class DefaultHeartbeatService implements HeartbeatService {
    private final ScheduledExecutorService scheduler;
    private final NodeStatusManager statusManager;
    private long heartbeatInterval = 5000; // 默认5秒
    private long heartbeatTimeout = 3000;  // 默认3秒超时
    private volatile boolean running = false;

    public DefaultHeartbeatService(NodeStatusManager statusManager) {
        this.statusManager = statusManager;
        this.scheduler = Executors.newSingleThreadScheduledExecutor();
    }

    @Override
    public void start() {
        running = true;
        scheduler.scheduleAtFixedRate(this::heartbeat, 0, heartbeatInterval, TimeUnit.MILLISECONDS);
    }

    @Override
    public void stop() {
        running = false;
        scheduler.shutdown();
        try {
            scheduler.awaitTermination(5, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    private void heartbeat() {
        if (!running) return;
        
        for (ClusterNode node : statusManager.getAllNodes()) {
            checkNode(node);
        }
    }

    @Override
    public void checkNode(ClusterNode node) {
        try {
            String url = String.format("http://%s:%d/ping", node.getHost(), node.getPort());
            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();
            conn.setConnectTimeout((int) heartbeatTimeout);
            conn.setReadTimeout((int) heartbeatTimeout);
            conn.setRequestMethod("GET");
            
            int responseCode = conn.getResponseCode();
            if (responseCode == 200) {
                statusManager.updateNodeStatus(node, NodeStatus.RUNNING);
            } else {
                statusManager.updateNodeStatus(node, NodeStatus.UNREACHABLE);
            }
        } catch (IOException e) {
            statusManager.updateNodeStatus(node, NodeStatus.UNREACHABLE);
        }
    }

    @Override
    public void setHeartbeatInterval(long interval) {
        this.heartbeatInterval = interval;
    }

    @Override
    public void setHeartbeatTimeout(long timeout) {
        this.heartbeatTimeout = timeout;
    }
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/cluster/heartbeat/HeartbeatService.java ===

package com.microtomcat.cluster.heartbeat;

import com.microtomcat.cluster.ClusterNode;

public interface HeartbeatService {
    void start();
    void stop();
    void checkNode(ClusterNode node);
    void setHeartbeatInterval(long interval);
    void setHeartbeatTimeout(long timeout);
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/container/Wrapper.java ===

package com.microtomcat.container;

import com.microtomcat.connector.Request;
import com.microtomcat.connector.Response;
import com.microtomcat.lifecycle.LifecycleException;
import com.microtomcat.servlet.Servlet;
import com.microtomcat.servlet.ServletException;
import com.microtomcat.context.Context;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.servlet.Filter;
import javax.servlet.ServletRequestListener;

public class Wrapper extends ContainerBase {
    private Servlet servlet;
    private final String servletClass;
    private Map<String, String> initParameters = new HashMap<>();
    private List<Filter> filterChain = new ArrayList<>();
    private List<ServletRequestListener> requestListeners = new ArrayList<>();

    public Wrapper(String name, String servletClass) {
        this.name = name;
        this.servletClass = servletClass;
    }

    @Override
    protected void initInternal() throws LifecycleException {
        try {
            Context context = (Context) getParent();
            Class<?> servletClass;
            
            // 1. 如果是框架提供的 Servlet (com.microtomcat.example.*)，用系统类加载器
            if (this.servletClass.startsWith("com.microtomcat.")) {
                ClassLoader loader = getParent().getClass().getClassLoader();
                log("For servlet in target/classes, loading servlet class: " + this.servletClass + " using loader: " + loader);
                servletClass = loader.loadClass(this.servletClass);
            } 
            // 2. 如果是应用的 Servlet，用对应的 WebAppClassLoader
            else {
                ClassLoader loader = context.getWebAppClassLoader();
                log("For servlet in webroot, loading servlet class: " + this.servletClass + " using loader: " + loader);
                servletClass = loader.loadClass(this.servletClass);
            }

            // 确保它实现了 Servlet 接口
            if (!com.microtomcat.servlet.Servlet.class.isAssignableFrom(servletClass)) {
                throw new LifecycleException("Class " + servletClass + " is not a Servlet");
            }
            
            servlet = (com.microtomcat.servlet.Servlet) servletClass.getDeclaredConstructor().newInstance();
            servlet.init();
            
        } catch (Exception e) {
            throw new LifecycleException("Failed to initialize servlet: " + name, e);
        }
    }

    @Override
    public void invoke(Request request, Response response) {
        try {
            if (servlet != null) {
                servlet.service(request, response);
            } else {
                throw new ServletException("No servlet instance available");
            }
        } catch (ServletException | IOException e) {
            log("Error invoking servlet: " + e.getMessage());
            try {
                response.sendError(500, "Internal Server Error: " + e.getMessage());
            } catch (IOException ioe) {
                log("Failed to send error response: " + ioe.getMessage());
            }
        }
    }

    @Override
    protected void startInternal() throws LifecycleException {
        log("Starting Wrapper: " + name);
        // try {
        //     if (servlet == null && servletClass != null) {
        //         Class<?> clazz = Class.forName(servletClass);
        //         servlet = (Servlet) clazz.getDeclaredConstructor().newInstance();
        //         servlet.init();
        //     }
        // } catch (Exception e) {
        //     throw new LifecycleException("Failed to initialize servlet", e);
        // }
    }

    @Override
    protected void stopInternal() throws LifecycleException {
        log("Stopping Wrapper: " + name);
        if (servlet != null) {
            servlet.destroy();
            servlet = null;
        }
    }

    @Override
    protected void destroyInternal() throws LifecycleException {
        log("Destroying Wrapper: " + name);
    }

    public void addInitParameter(String name, String value) {
        initParameters.put(name, value);
    }

    public void addFilter(Filter filter) {
        filterChain.add(filter);
    }

    public void addRequestListener(ServletRequestListener listener) {
        requestListeners.add(listener);
    }
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/context/Context.java ===

package com.microtomcat.context;

import com.microtomcat.container.Container;
import com.microtomcat.container.ContainerBase;
import com.microtomcat.container.Wrapper;
import com.microtomcat.example.SessionTestServlet;
import com.microtomcat.connector.Request;
import com.microtomcat.connector.Response;
import com.microtomcat.lifecycle.LifecycleException;
import com.microtomcat.session.SessionManager;
import com.microtomcat.loader.WebAppClassLoader;
import com.microtomcat.loader.ClassLoaderManager;
import java.io.File;
import java.io.IOException;

public class Context extends ContainerBase {
    private final String docBase;
    private final WebAppClassLoader webAppClassLoader;
    private final SessionManager sessionManager;

    public Context(String name, String docBase) throws IOException {
        this.name = name;
        this.docBase = docBase;
        this.sessionManager = new SessionManager();
        
        this.webAppClassLoader = ClassLoaderManager.createWebAppClassLoader(docBase);
        
        registerDefaultServlets();
    }

    private void registerDefaultServlets() {
        try {
            // 根据上下文路径注册不同的 Servlet
            if (name.equals("")) {  // 根上下文
                // 注册 HelloServlet
                log("Registering HelloServlet...");
                Wrapper helloWrapper = new Wrapper("HelloServlet", "com.microtomcat.example.HelloServlet");
                Wrapper sessionTestWrapper = new Wrapper("SessionTestServlet", "com.microtomcat.example.SessionTestServlet");
                addChild(helloWrapper);
                addChild(sessionTestWrapper);
                Wrapper webRootWrapper = new Wrapper("WebRootServlet", "WebRootServlet");
                addChild(webRootWrapper);
            } else if (name.equals("/app1")) {  // app1 上下文
                // 注册 App1Servlet
                log("Registering App1Servlet...");
                Wrapper app1Wrapper = new Wrapper("App1Servlet", "App1Servlet");
                addChild(app1Wrapper);
            } else if (name.equals("/app2")) {  // app2 上下文
                // 注册 App2Servlet
                log("Registering App2Servlet...");
                Wrapper app2Wrapper = new Wrapper("App2Servlet", "App2Servlet");
                addChild(app2Wrapper);
            }

            log("Successfully registered servlets for context: " + name);
        } catch (Exception e) {
            log("Error registering servlets: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public String getDocBase() {
        return docBase;
    }

    public WebAppClassLoader getWebAppClassLoader() {
        return webAppClassLoader;
    }

    public SessionManager getSessionManager() {
        return sessionManager;
    }

    @Override
    public void invoke(Request request, Response response) {
        request.setContext(this);
        
        String servletPath = getServletPath(request.getUri());
        if (servletPath != null && servletPath.startsWith("/servlet/")) {
            String servletName = servletPath.substring("/servlet/".length());
            // 移除路径分隔符，只保留 Servlet 名称
            servletName = servletName.replace('/', '.');
            try {
                Wrapper wrapper = (Wrapper) findChild(servletName);
                if (wrapper == null) {
                    // 动态创建Wrapper，使用简单的类名
                    wrapper = new Wrapper(servletName, servletName.substring(servletName.lastIndexOf('.') + 1));
                    addChild(wrapper);
                    wrapper.init();
                    wrapper.start();
                }
                wrapper.invoke(request, response);
            } catch (Exception e) {
                log("Error processing servlet request: " + e.getMessage());
                try {
                    response.sendError(500, "Internal Server Error: " + e.getMessage());
                } catch (IOException ioe) {
                    log("Failed to send error response: " + ioe.getMessage());
                }
            }
        } else {
            // 处理静态资源
            try {
                String relativePath = request.getUri();
                // 如果URI以上下文路径开头，移除它
                if (relativePath.startsWith(name) && !name.equals("/")) {
                    relativePath = relativePath.substring(name.length());
                }
                // 如果路径是目录，默认查找 index.html
                if (relativePath.endsWith("/")) {
                    relativePath += "index.html";
                }
                
                File file = new File(docBase, relativePath);
                if (file.exists() && file.isFile()) {
                    response.sendStaticResource(file);
                } else {
                    response.sendError(404, "File Not Found: " + relativePath);
                }
            } catch (IOException e) {
                log("Error sending static resource: " + e.getMessage());
                try {
                    response.sendError(500, "Internal Server Error: " + e.getMessage());
                } catch (IOException ioe) {
                    log("Failed to send error response: " + ioe.getMessage());
                }
            }
        }
    }

    private String getServletPath(String uri) {
        if (uri == null) {
            return null;
        }
        // 如果URI以上下文路径开头，移除它
        if (uri.startsWith(name) && !name.equals("/")) {
            return uri.substring(name.length());
        }
        return uri;
    }

    @Override
    protected void initInternal() throws LifecycleException {
        log("Initializing context: " + name);
        // 初始化所有子容器（包括 Servlet Wrapper）
        Container[] children = findChildren();
        for (Container child : children) {
            child.init();
        }
    }

    @Override
    protected void startInternal() throws LifecycleException {
        log("Starting context: " + name);
        Container[] children = findChildren();
        for (Container child : children) {
            child.start();
        }
    }

    @Override
    protected void stopInternal() throws LifecycleException {
        log("Stopping context: " + name);
        Container[] children = findChildren();
        for (Container child : children) {
            child.stop();
        }
    }

    @Override
    protected void destroyInternal() throws LifecycleException {
        log("Destroying context: " + name);
        webAppClassLoader.destroy();
    }
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/context/ContextManager.java ===

package com.microtomcat.context;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import com.microtomcat.lifecycle.LifecycleBase;
import com.microtomcat.lifecycle.LifecycleException;
public class ContextManager extends LifecycleBase {
    private final Map<String, Context> contexts = new ConcurrentHashMap<>();
    private final String webRoot;

    public ContextManager(String webRoot) {
        this.webRoot = webRoot;
    }

    @Override
    protected void initInternal() throws LifecycleException {
        log("Initializing ContextManager");
        // 初始化所有上下文
        for (Context context : contexts.values()) {
            context.init();
        }
    }

    @Override
    protected void startInternal() throws LifecycleException {
        log("Starting ContextManager");
        for (Context context : contexts.values()) {
            context.start();
        }
    }

    @Override
    protected void stopInternal() throws LifecycleException {
        log("Stopping ContextManager");
        for (Context context : contexts.values()) {
            context.stop();
        }
    }

    @Override
    protected void destroyInternal() throws LifecycleException {
        log("Destroying ContextManager");
        for (Context context : contexts.values()) {
            context.destroy();
        }
        contexts.clear();
    }

    public void createContext(String contextPath, String docBase) {
        try {
            Context context = new Context(contextPath, docBase);
            contexts.put(contextPath, context);
            log("Created context: " + contextPath + ", docBase: " + docBase);
        } catch (IOException e) {
            log("Failed to create context: " + contextPath + ", error: " + e.getMessage());
        }
    }

    public Context getContext(String uri) {
        // 首先尝试精确匹配
        for (Map.Entry<String, Context> entry : contexts.entrySet()) {
            String contextPath = entry.getKey();
            if (!contextPath.isEmpty() && uri.startsWith(contextPath)) {
                return entry.getValue();
            }
        }
        // 如果没有找到匹配的应用上下文，返回根上下文
        return contexts.get("");
    }

    private void log(String message) {
        System.out.println("[ContextManager] " + message);
    }
}

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/loader/WebAppClassLoader.java ===

package com.microtomcat.loader;

import java.io.*;
import java.net.URL;
import java.io.IOException;
import java.io.File;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import com.microtomcat.servlet.Servlet;
import com.microtomcat.servlet.ServletException;

/**
 * WebAppClassLoader 专门加载某个web应用 /appX 下的类(通常是 WEB-INF/classes、WEB-INF/lib/*.jar)
 * 这里仅演示从 WEB-INF/classes 中加载 .class 文件
 */
public class WebAppClassLoader extends MicroTomcatClassLoader {

    private final String webAppPath;
    private final Map<String, Servlet> servletCache = new ConcurrentHashMap<>();

    public WebAppClassLoader(String webAppPath, ClassLoader parent) throws IOException {
        super(new URL[0], parent);
        this.webAppPath = webAppPath;

        // 1. 添加当前 Web 应用的 WEB-INF/classes
        addRepository(webAppPath + "/WEB-INF/classes");

        // 2. 如果有 WEB-INF/lib/*.jar，也可以在这里循环 addRepository(...)
        // 演示省略

        log("WebAppClassLoader for [" + webAppPath + "] repositories:");
        for (File path : repositoryPaths) {
            log(" - " + path.getAbsolutePath());
        }
    }

    /**
     * 重写 loadClass，以实现对 com.microtomcat.servlet.* 以及 HelloServlet 的特殊委派
     */
    @Override
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        synchronized (getClassLoadingLock(name)) {
            log("WebAppClassLoader[" + webAppPath + "] - Attempting to load class: " + name);

            // 1. 如果已经加载过，直接返回
            Class<?> c = findLoadedClass(name);
            if (c != null) {
                log("Class already loaded: " + name + " by " + c.getClassLoader());
                return c;
            }

            log("ricky: " + name);

            // 2. 对框架类，委托给父加载器
            if (name.startsWith("com.microtomcat.example.HelloServlet")
            || name.startsWith("com.microtomcat.servlet.HttpServlet")
            ) {
                log("Delegating " + name + " to parent because it's a framework class");
                try {
                    return getParent().loadClass(name);
                } catch (ClassNotFoundException e) {
                    log("Parent failed to load " + name + ", will try locally");
                }
            }

            // 3. 其他类先尝试自己加载
            try {
                return findClass(name);
            } catch (ClassNotFoundException e) {
                // 4. 最后再尝试父加载器
                return getParent().loadClass(name);
            }
        }
    }

    /**
     * loadServlet 是你在 Servlet 容器的某处调用，比如:
     *   WebAppClassLoader loader = createWebAppClassLoader(...);
     *   Servlet servlet = loader.loadServlet("/servlet/App1Servlet");
     */
    public Servlet loadServlet(String servletPath) throws ServletException {
        try {
            if (servletCache.containsKey(servletPath)) {
                return servletCache.get(servletPath);
            }

            // 例如 /servlet/App1Servlet => "App1Servlet"
            String servletName = servletPath.substring(servletPath.lastIndexOf("/") + 1);
            Class<?> servletClass;

            // 如果是 rootContext (webroot 对应 path=""),
            // 那么有可能要加载 WebRootServlet、或者你想把 "HelloServlet" 也放这边？
            // 不过我们已经在 loadClass() 里对 HelloServlet 做了"交给 parent"的逻辑
            // 所以这里，如果你想保持旧的com.microtomcat.example.xxx 逻辑，可以这样：
            if (webAppPath.equals("webroot")) {
                String maybeFullName = "com.microtomcat.example." + servletName;
                log("Trying to load as: " + maybeFullName);
                servletClass = loadClass(maybeFullName);
            } else {
                // 对 /app1、/app2，里面通常就是 "App1Servlet"、"App2Servlet"
                log("Trying to load as local class: " + servletName);
                servletClass = loadClass(servletName);
            }

            // 判断是否实现了 Servlet 接口
            if (!Servlet.class.isAssignableFrom(servletClass)) {
                throw new ServletException("Class " + servletClass.getName() + " is not a Servlet");
            }

            Servlet servlet = (Servlet) servletClass.getDeclaredConstructor().newInstance();
            servlet.init();
            servletCache.put(servletPath, servlet);
            return servlet;
        } catch (Exception e) {
            throw new ServletException("Error loading servlet: " + servletPath, e);
        }
    }

    /**
     * WebAppClassLoader 覆盖 findClass，
     * 以实现"从 webAppPath/WEB-INF/classes 下的 .class 文件"加载
     */
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        log("WebAppClassLoader[" + webAppPath + "] - Finding class: " + name);

        // 将类名转换为文件路径
        String classFilePath = name.replace('.', '/') + ".class";
        File classFile = new File(webAppPath + "/WEB-INF/classes", classFilePath);

        // 如果文件存在，就读入字节定义类
        byte[] classData = loadClassData(classFile);
        if (classData == null) {
            // 如果 loadClassData 返回 null，说明本 webapp 也没这个类
            throw new ClassNotFoundException("Could not find class: " + name);
        }

        // defineClass() 会把这个类定义到当前 WebAppClassLoader 里
        return defineClass(name, classData, 0, classData.length);
    }

    /**
     * 在 WebAppClassLoader 销毁时，把缓存清空
     */
    public void destroy() {
        servletCache.values().forEach(Servlet::destroy);
        servletCache.clear();
        try {
            close();
        } catch (IOException e) {
            log("Error destroying WebAppClassLoader: " + e.getMessage());
        }
    }
}


=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/pipeline/ValveContext.java ===

package com.microtomcat.pipeline;

import com.microtomcat.connector.Request;
import com.microtomcat.connector.Response;
import java.io.IOException;
import com.microtomcat.servlet.ServletException;

public interface ValveContext {
    void invokeNext(Request request, Response response) 
        throws IOException, ServletException;
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/processor/Processor.java ===

package com.microtomcat.processor;

import com.microtomcat.connector.Request;
import com.microtomcat.connector.Response;
import com.microtomcat.context.Context;
import com.microtomcat.context.ContextManager;
import com.microtomcat.lifecycle.LifecycleBase;
import com.microtomcat.pipeline.Pipeline;
import com.microtomcat.pipeline.StandardPipeline;
import com.microtomcat.pipeline.valve.AccessLogValve;
import com.microtomcat.pipeline.valve.AuthenticatorValve;
import com.microtomcat.pipeline.valve.StandardValve;
import com.microtomcat.servlet.Servlet;
import com.microtomcat.servlet.ServletException;
import com.microtomcat.servlet.ServletLoader;
import com.microtomcat.session.SessionManager;
import java.io.*;
import java.net.Socket;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import com.microtomcat.lifecycle.LifecycleException;
import com.microtomcat.container.Engine;

public class Processor extends LifecycleBase {
    private final String webRoot;
    private final Engine engine;
    private final Pipeline pipeline;

    public Processor(String webRoot, Engine engine) {
        this.webRoot = webRoot;
        this.engine = engine;
        
        this.pipeline = new StandardPipeline();
        pipeline.addValve(new AccessLogValve());
        pipeline.addValve(new AuthenticatorValve());
        pipeline.setBasic(new StandardValve(webRoot));
    }

    @Override
    protected void initInternal() throws LifecycleException {
        log("Initializing processor");
    }

    @Override
    protected void startInternal() throws LifecycleException {
        log("Starting processor");
    }

    @Override
    protected void stopInternal() throws LifecycleException {
        log("Stopping processor");
    }

    @Override
    protected void destroyInternal() throws LifecycleException {
        log("Destroying processor");
    }

    private void log(String message) {
        System.out.println("[Processor] " + message);
    }

    public void process(Socket socket) {
        try {
            Request request = new Request(socket.getInputStream(), null);
            Response response = new Response(socket.getOutputStream(), request);
            
            request.parse();
            
            // 直接使用Engine处理请求
            engine.invoke(request, response);
            
        } catch (Exception e) {
            log("Error processing request: " + e.getMessage());
        }
    }
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/processor/ProcessorPool.java ===

package com.microtomcat.processor;

import com.microtomcat.servlet.ServletLoader;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import com.microtomcat.session.SessionManager;
import com.microtomcat.context.Context;
import com.microtomcat.context.ContextManager;
import com.microtomcat.processor.ProcessorPoolMBean;

import java.io.IOException;
import com.microtomcat.lifecycle.LifecycleBase;
import com.microtomcat.lifecycle.LifecycleException;
import com.microtomcat.container.Container;
import com.microtomcat.container.Engine;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ThreadPoolExecutor;

public class ProcessorPool extends LifecycleBase implements ProcessorPoolMBean {
    private final BlockingQueue<Processor> pool;
    private final List<Processor> allProcessors;
    private final int maxProcessors;
    private final String webRoot;
    private final Engine engine;
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition notEmpty = lock.newCondition();
    private final Condition notFull = lock.newCondition();
    private final AtomicInteger activeProcessors = new AtomicInteger(0);
    private final AtomicLong totalProcessingTime = new AtomicLong(0);
    private final AtomicLong requestCount = new AtomicLong(0);
    private final AtomicInteger currentLoad = new AtomicInteger(0);
    private final AtomicLong totalRequests = new AtomicLong(0);
    private final ExecutorService executorService;

    public ProcessorPool(int maxProcessors, String webRoot, Engine engine) {
        this.maxProcessors = maxProcessors;
        this.webRoot = webRoot;
        this.engine = engine;
        this.pool = new ArrayBlockingQueue<>(maxProcessors);
        this.allProcessors = new ArrayList<>();
        
        // 预创建处理器
        int initialProcessors = Math.min(maxProcessors / 2, 10);
        for (int i = 0; i < initialProcessors; i++) {
            createProcessor();
        }
        
        this.executorService = new ThreadPoolExecutor(
            1,                      // 核心线程数
            maxProcessors,            // 最大线程数
            60L,                   // 空闲线程存活时间
            TimeUnit.SECONDS,      // 时间单位
            new ArrayBlockingQueue<>(100)  // 工作队列
        );
    }

    @Override
    protected void initInternal() throws LifecycleException {
        log("Initializing ProcessorPool with " + allProcessors.size() + " processors");
        for (Processor processor : allProcessors) {
            processor.init();
        }
    }

    @Override
    protected void startInternal() throws LifecycleException {
        log("Starting ProcessorPool");
        for (Processor processor : allProcessors) {
            processor.start();
        }
    }

    @Override
    protected void stopInternal() throws LifecycleException {
        log("Stopping ProcessorPool");
        for (Processor processor : allProcessors) {
            processor.stop();
        }
    }

    @Override
    protected void destroyInternal() throws LifecycleException {
        log("Destroying ProcessorPool");
        for (Processor processor : allProcessors) {
            processor.destroy();
        }
        pool.clear();
        allProcessors.clear();
    }

    private void log(String message) {
        System.out.println("[ProcessorPool] " + message);
    }

    public Processor getProcessor(long timeout) throws InterruptedException {
        lock.lock();
        try {
            long nanos = TimeUnit.MILLISECONDS.toNanos(timeout);
            while (pool.isEmpty() && nanos > 0) {
                nanos = notEmpty.awaitNanos(nanos);
            }
            Processor processor = pool.poll();
            if (processor != null) {
                notFull.signal();
            }
            return processor;
        } finally {
            lock.unlock();
        }
    }

    public void releaseProcessor(Processor processor) {
        lock.lock();
        try {
            pool.offer(processor);
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    private void createProcessor() {
        Processor processor = new Processor(webRoot, engine);
        allProcessors.add(processor);
        pool.offer(processor);
    }

    public int getActiveCount() {
        return allProcessors.size() - pool.size();
    }

    public int getTotalCount() {
        return allProcessors.size();
    }

    public void recordProcessingTime(long processingTimeMs) {
        totalProcessingTime.addAndGet(processingTimeMs);
        requestCount.incrementAndGet();
    }

    @Override
    public double getAverageProcessingTime() {
        long count = requestCount.get();
        return count > 0 ? (double) totalProcessingTime.get() / count : 0;
    }

    public int getCurrentLoad() {
        return currentLoad.get();
    }

    public void recordRequest(long processingTimeMs) {
        totalRequests.incrementAndGet();
        totalProcessingTime.addAndGet(processingTimeMs);
    }

    public long getRequestCount() {
        return totalRequests.get();
    }

    protected void incrementLoad() {
        currentLoad.incrementAndGet();
    }

    protected void decrementLoad() {
        currentLoad.decrementAndGet();
    }

    @Override
    public int getActiveProcessors() {
        return getActiveCount();
    }
    
    @Override
    public int getIdleProcessors() {
        return pool.size();
    }
    
    @Override
    public long getTotalProcessedRequests() {
        return getRequestCount();
    }
    
    @Override
    public void setMaxProcessors(int max) {
        // 动态调整处理器池大小
        lock.lock();
        try {
            while (allProcessors.size() < max) {
                createProcessor();
            }
        } finally {
            lock.unlock();
        }
    }
    
    @Override
    public void invalidateAllSessions() {
        // 遍历所有 Context 并使其 Session 失效
        for (Container child : engine.findChildren()) {
            if (child instanceof Context) {
                Context context = (Context) child;
                context.getSessionManager().invalidateAll();
            }
        }
    }

    public ExecutorService getExecutor() {
        return executorService;
    }
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/processor/ProcessorPoolMBean.java ===

package com.microtomcat.processor;

/**
 * ProcessorPool的JMX管理接口
 */
public interface ProcessorPoolMBean {
    // 处理器池状态
    int getActiveProcessors();
    int getIdleProcessors();
    
    // 性能指标
    long getTotalProcessedRequests();
    double getAverageProcessingTime();
    
    // 操作
    void setMaxProcessors(int max);
    void invalidateAllSessions();
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/server/AbstractHttpServer.java ===

package com.microtomcat.server;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import com.microtomcat.container.Engine;
import com.microtomcat.lifecycle.LifecycleException;
import com.microtomcat.processor.ProcessorPool;

public abstract class AbstractHttpServer {
    protected final ServerConfig config;
    protected static final String WEB_ROOT = "webroot";
    protected ProcessorPool processorPool;
    protected Engine engine;
    
    protected AbstractHttpServer(ServerConfig config) {
        this.config = config;
    }
    
    public abstract void start() throws LifecycleException;
    public abstract void stop() throws LifecycleException;
    
    protected void log(String message) {
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_TIME);
        System.out.printf("[%s] %s%n", timestamp, message);
    }
    
    protected void initInternal() throws LifecycleException {
        // 基础初始化逻辑
    }
    
    protected void destroyInternal() throws LifecycleException {
        // 基础销毁逻辑
    }
    
    public void init() throws LifecycleException {
        initInternal();
    }
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/server/BlockingHttpServer.java ===

package com.microtomcat.server;

import com.microtomcat.connector.Connector;
import com.microtomcat.processor.Processor;
import com.microtomcat.processor.ProcessorPool;
import com.microtomcat.servlet.ServletLoader;
import com.microtomcat.session.SessionManager;
import com.microtomcat.context.Context;
import com.microtomcat.container.Engine;
import com.microtomcat.container.Host;
import com.microtomcat.lifecycle.LifecycleException;
import com.microtomcat.jmx.MBeanRegistry;
import com.microtomcat.jmx.StandardServer;
import javax.management.JMException;

import java.io.*;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import com.microtomcat.cluster.ClusterNode;
import com.microtomcat.cluster.ClusterRegistry;
import com.microtomcat.cluster.NodeStatus;
import com.microtomcat.cluster.config.ClusterConfig;
import com.microtomcat.cluster.config.ClusterConfigLoader;

public class BlockingHttpServer extends AbstractHttpServer {
    private final ExecutorService executorService;
    private final ProcessorPool processorPool;
    private final Connector connector;
    private final Engine engine;
    private volatile boolean running = true;
    private MBeanRegistry mbeanRegistry;
    private StandardServer serverMBean;
    private ClusterConfig clusterConfig;
    private ClusterRegistry clusterRegistry;

    public BlockingHttpServer(ServerConfig config) {
        super(config);
        this.executorService = Executors.newFixedThreadPool(config.getThreadPoolSize());
        
        this.engine = new Engine("MicroTomcat", "localhost");
        
        Host defaultHost = new Host("localhost");
        engine.addChild(defaultHost);
        
        try {
            Context rootContext = new Context("", config.getWebRoot());
            defaultHost.addChild(rootContext);
            
            Context app1Context = new Context("/app1", config.getWebRoot() + "/app1");
            Context app2Context = new Context("/app2", config.getWebRoot() + "/app2");
            defaultHost.addChild(app1Context);
            defaultHost.addChild(app2Context);
            
            this.processorPool = new ProcessorPool(
                100,
                config.getWebRoot(),
                engine
            );
            
            this.connector = new Connector(config.getPort(), processorPool);
            
            engine.init();
            processorPool.init();
            connector.init();
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to initialize server", e);
        }
    }

    @Override
    public void start() {
        try {
            engine.start();
            processorPool.start();
            connector.start();
            
            for (int i = 0; i < config.getThreadPoolSize(); i++) {
                executorService.submit(new ConnectionHandler());
            }
            
            log("Server started on port " + config.getPort());
            
            synchronized (this) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        } catch (LifecycleException  e) {
            throw new RuntimeException("Failed to start server", e);
        }
    }

    private class ConnectionHandler implements Runnable {
        @Override
        public void run() {
            while (running) {
                Socket socket = connector.getSocket();
                if (socket != null) {
                    handleRequest(socket);
                }
            }
        }
    }

    private void handleRequest(Socket socket) {
        Processor processor = null;
        try {
            processor = processorPool.getProcessor(5000); // 5秒超时
            if (processor != null) {
                log(String.format("Acquired processor (active/total: %d/%d) for request from: %s",
                    processorPool.getActiveCount(),
                    processorPool.getTotalCount(),
                    socket.getInetAddress()));
                processor.process(socket);
            } else {
                log("No processor available, sending 503 response to: " + socket.getInetAddress());
                try (OutputStream output = socket.getOutputStream()) {
                    String response = "HTTP/1.1 503 Service Unavailable\r\n" +
                            "Content-Type: text/plain\r\n" +
                            "Content-Length: 35\r\n" +
                            "\r\n" +
                            "Server is too busy, please try later.";
                    output.write(response.getBytes());
                }
            }
        } catch (InterruptedException e) {
            log("Processor acquisition interrupted for " + socket.getInetAddress() + ": " + e.getMessage());
        } catch (IOException e) {
            log("Error processing request from " + socket.getInetAddress() + ": " + e.getMessage());
        } finally {
            if (processor != null) {
                processorPool.releaseProcessor(processor);
                log("Released processor back to pool");
            }
            try {
                socket.close();
            } catch (IOException e) {
                log("Error closing socket for " + socket.getInetAddress() + ": " + e.getMessage());
            }
        }
    }

    @Override
    public void stop() {
        running = false;
        try {
            connector.stop();
            processorPool.stop();
            engine.stop();
            executorService.shutdown();
        } catch (Exception e) {
            log("Error while stopping server: " + e.getMessage());
        }
    }

    @Override
    protected void initInternal() throws LifecycleException {
        super.initInternal();
        
        try {
            System.out.println("Initializing JMX support...");
            mbeanRegistry = new MBeanRegistry();
            
            System.out.println("Registering Server MBean...");
            serverMBean = new StandardServer(processorPool, engine);
            mbeanRegistry.registerMBean(serverMBean, "StandardServer");
            
            System.out.println("Registering ProcessorPool MBean...");
            mbeanRegistry.registerMBean(processorPool, "ProcessorPool");
            
            System.out.println("Registering Connector MBean...");
            mbeanRegistry.registerMBean(connector, "Connector");
            
            System.out.println("JMX initialization completed.");
        } catch (JMException e) {
            throw new LifecycleException("Failed to initialize JMX support", e);
        }
        
        // 初始化集群配置
        initializeCluster();
    }

    private void initializeCluster() {
        try {
            // 1. 加载集群配置
            ClusterConfigLoader loader = new ClusterConfigLoader();
            clusterConfig = loader.loadConfig();
            
            // 2. 获取集群注册表实例
            clusterRegistry = ClusterRegistry.getInstance();
            
            // 3. 注册配置的节点
            for (ClusterConfig.NodeConfig nodeConfig : clusterConfig.getNodes()) {
                ClusterNode node = new ClusterNode(
                    nodeConfig.getName(),
                    nodeConfig.getHost(),
                    nodeConfig.getPort()
                );
                
                // 如果是当前节点，设置状态为RUNNING
                if (isCurrentNode(nodeConfig)) {
                    node.setStatus(NodeStatus.RUNNING);
                }
                
                clusterRegistry.registerNode(node);
            }
            
            log("Cluster initialized with " + clusterConfig.getNodes().size() + " nodes");
            
        } catch (Exception e) {
            log("Failed to initialize cluster: " + e.getMessage());
        }
    }
    
    private boolean isCurrentNode(ClusterConfig.NodeConfig nodeConfig) {
        return nodeConfig.getPort() == config.getPort() && 
               "localhost".equals(nodeConfig.getHost());
    }

    @Override
    protected void destroyInternal() throws LifecycleException {
        // 在服务器关闭时清理集群资源
        if (clusterRegistry != null) {
            for (ClusterNode node : clusterRegistry.getAllNodes()) {
                if (isCurrentNode(node)) {
                    node.setStatus(NodeStatus.STOPPED);
                    clusterRegistry.unregisterNode(node.getId());
                }
            }
        }
        super.destroyInternal();
    }

    private boolean isCurrentNode(ClusterNode node) {
        return node.getPort() == config.getPort() && 
               "localhost".equals(node.getHost());
    }
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/server/HttpServerFactory.java ===

package com.microtomcat.server;

import java.io.IOException;

public class HttpServerFactory {
    public static AbstractHttpServer createServer(ServerConfig config) throws IOException {
        return config.isNonBlocking() 
            ? new NonBlockingHttpServer(config)
            : new BlockingHttpServer(config);
    }
} 

=== /Users/yang/code/study/micro-tomcat/src/main/java/com/microtomcat/server/NonBlockingHttpServer.java ===

package com.microtomcat.server;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

import com.microtomcat.lifecycle.LifecycleException;

public class NonBlockingHttpServer extends AbstractHttpServer {
    private final Selector selector;
    private final ServerSocketChannel serverChannel;

    public NonBlockingHttpServer(ServerConfig config) throws IOException {
        super(config);
        this.selector = Selector.open();
        this.serverChannel = ServerSocketChannel.open();
        this.serverChannel.configureBlocking(false);
        this.serverChannel.socket().bind(new InetSocketAddress(config.getPort()));
        this.serverChannel.register(selector, SelectionKey.OP_ACCEPT);
    }

    @Override
    public void start() throws LifecycleException {
        try {
            log("Non-blocking server started on port: " + config.getPort());
            
            while (!Thread.currentThread().isInterrupted()) {
                selector.select();
                Set<SelectionKey> selectedKeys = selector.selectedKeys();
                Iterator<SelectionKey> iter = selectedKeys.iterator();

                while (iter.hasNext()) {
                    SelectionKey key = iter.next();
                    iter.remove();

                    if (key.isAcceptable()) {
                        SocketChannel client = serverChannel.accept();
                        client.configureBlocking(false);
                        client.register(selector, SelectionKey.OP_READ);
                        log("New connection accepted from: " + client.getRemoteAddress());
                    } else if (key.isReadable()) {
                        handleRead(key);
                    }
                }
            }
        } catch (IOException e) {
            throw new LifecycleException("Error starting server: " + e.getMessage(), e);
        }
    }

    @Override
    public void stop() {
        try {
            selector.close();
            serverChannel.close();
        } catch (IOException e) {
            log("Error while stopping server: " + e.getMessage());
        }
    }
    
    private void handleRead(SelectionKey key) throws IOException {
        SocketChannel client = (SocketChannel) key.channel();
        try {
            // 创建缓冲区读取数据
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            int bytesRead = client.read(buffer);
            
            if (bytesRead == -1) {
                // 客户端关闭连接
                key.cancel();
                client.close();
                return;
            }
            
            // 处理HTTP请求
            buffer.flip();
            byte[] data = new byte[buffer.remaining()];
            buffer.get(data);
            String request = new String(data);
            
            // 发送响应
            String response = "HTTP/1.1 200 OK\r\n" +
                            "Content-Type: text/plain\r\n" +
                            "Content-Length: 13\r\n" +
                            "\r\n" +
                            "Hello, World!";
            
            ByteBuffer responseBuffer = ByteBuffer.wrap(response.getBytes());
            client.write(responseBuffer);
            
            // 关闭连接
            key.cancel();
            client.close();
            
        } catch (IOException e) {
            log("Error processing request: " + e.getMessage());
            key.cancel();
            client.close();
        }
    }
} 