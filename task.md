### Micro Tomcat 项目任务列表

以下是一个帮助实现 Micro Tomcat 的任务列表，分为三个阶段：基础阶段（构建核心功能）、中级阶段（引入规范与优化性能）、高级阶段（扩展功能与容错处理）。每个阶段提供明确的学习目标、任务说明和产出要求，帮助逐步构建和优化 Micro Tomcat。

---

### 基础阶段（核心功能构建）

**学习目标**：  
- [ ] 掌握 HTTP 协议的基本请求与响应机制  
- [ ] 理解 Java Socket 编程，实现基础 HTTP 服务  
- [ ] 构建最小化的 HTTP Server，支持静态资源的请求与响应

#### 任务1：搭建项目结构与环境  
- [x] 创建 Maven 项目，搭建基础目录结构：`src/main/java` 和 `webroot`  
- [x] 定义核心类：`HttpServer`（监听请求）、`Request`（解析请求）、`Response`（生成响应）  
**产出要求**：  
- [x] 项目目录清晰，`HttpServer` 能启动并监听 8080 端口  

#### 任务2：实现简单的 HTTP Server  
**场景**：支持返回静态文件  
- [x] 在 `HttpServer` 中创建 `ServerSocket`，监听端口并接受请求  
- [x] 解析客户端请求，提取 URI 并读取 `webroot` 目录下对应文件  
- [x] 返回静态文件内容，同时设置 HTTP 状态码、内容长度、Content-Type 等响应头  
**产出要求**：  
- [x] 浏览器访问 `http://localhost:8080/hello.txt`，能正确返回文件内容  
- [x] 控制台打印请求日志（URI、客户端 IP 等）  

#### 任务3：解析 HTTP 请求  
**场景**：提取 HTTP 方法和 URI  
- [x] 编写 `Request` 类解析请求头，提取 HTTP 方法（如 GET）和 URI  
- [x] 在 `Response` 类中根据文件存在与否返回 200 或 404  
**产出要求**：  
- [x] 在控制台正确打印解析出的 HTTP 方法和 URI  
- [x] 未找到文件时返回 404，且带有合规的响应头和错误消息  

#### 任务4：实现简单的并发支持  
**场景**：多客户端同时访问  
- [x] 使用 `ExecutorService` 为每个请求创建独立线程处理  
- [x] 确保多个客户端可以同时请求不同资源  
**产出要求**：  
- [x] 浏览器同时访问多个 URL，能够正确返回响应且无阻塞  

---

### 中级阶段（规范与性能优化）

**学习目标**：  
- [ ] 引入 Servlet 规范，支持动态资源请求  
- [ ] 提升性能，引入 Processor 池化和多线程支持  
- [ ] 学习分层架构设计，拆分模块职责

#### 任务5：引入 Servlet 支持  
**场景**：处理动态资源  
- [x] 定义 `Servlet` 接口，包含 `service(Request, Response)` 方法  
- [x] 在请求解析中根据 URI 判断静态或动态资源请求，动态资源请求调用对应 Servlet 的 `service` 方法生成响应  
- [x] 使用 URLClassLoader 动态加载 Servlet 类  
**产出要求**：  
- [x] 浏览器访问 `http://localhost:8080/servlet/HelloServlet`，正确返回动态内容  
- [x] 在控制台记录 Servlet 加载和执行日志  

#### 任务6：模块化改造  
**场景**：拆分模块职责  
- [x] 将请求监听与处理分离：实现 `Connector` 负责监听请求，`Processor` 负责处理请求  
- [x] `Processor` 支持静态和动态资源分发  
**产出要求**：  
- [x] 项目模块划分清晰，`Connector` 和 `Processor` 各司其职  
- [x] 代码结构具有良好的可维护性  

#### 任务7：引入 Processor 池化  
**场景**：提升并发处理性能  
- [x] 使用池化技术管理 Processor 对象，避免频繁创建和销毁  
- [x] 限制 Processor 池大小，确保在高并发场景下资源不被耗尽  
**产出要求**：  
- [x] 支持至少 100 并发请求，正确返回响应且无明显性能下降  
- [x] 输出性能测试结果（如每秒请求处理量）  

#### 任务8：优化线程管理  
**场景**：提升线程利用率  
- [x] 为 Processor 引入线程池，实现多个线程同时处理不同请求  
- [x] 使用 `wait/notify` 机制实现 Processor 和 Connector 的同步  
**产出要求**：  
- [x] 多线程支持稳定，能够在高并发场景下无死锁和性能问题  

#### 任务9：实现 Session 管理  
**场景**：支持用户会话管理  
- [x] 实现 `Session` 类，支持属性的存取  
- [x] 使用 Cookie 或 URL 重写实现 Session ID 的传递  
- [x] 实现 Session 超时机制和定期清理  
- [x] 在 Request 和 Response 中添加 Session 相关方法  
**产出要求**：  
- [x] 能够正确创建、获取和维护用户 Session  
- [x] Session 在超时后自动失效并被清理  
- [x] 提供示例 Servlet 演示 Session 的使用（如简单的登录状态维护）  

---

### 高级阶段（扩展功能与容错处理）

**学习目标**：  
- [ ] 支持多应用部署和配置管理  
- [ ] 实现容错处理，支持异常捕获和友好错误页面  
- [ ] 提升可扩展性，支持高级特性如 HTTPS 和配置文件解析

#### 任务10：多应用支持  
**场景**：支持多个 Web 应用  
- [x] 在 `webroot` 目录下创建多个子目录，分别存放不同应用的静态资源和 Servlet 类  
- [x] 使用 `Context` 管理每个应用的资源，确保应用之间隔离  
**产出要求**：  
- [x] 能同时访问多个应用的资源，资源路径如 `/app1/hello.txt` 或 `/app2/servlet/HelloServlet`  
- [x] 在控制台打印每个请求的应用名称和 URI  

#### 任务11：引入配置文件支持  
**场景**：通过配置文件管理应用和服务  
- [ ] 使用 `web.xml` 定义 Servlet 映射、初始化参数等  
- [ ] 解析 `web.xml` 文件，在启动时加载配置  
**产出要求**：  
- [ ] 能根据 `web.xml` 的配置加载 Servlet 和路由规则  
- [ ] 输出配置加载日志，确保配置文件错误时提示清晰  

#### 任务12：支持 HTTPS  
**场景**：为通信加密  
- [ ] 使用 Java 的 SSL/TLS 支持，实现 HTTPS 服务  
- [ ] 配置自签名证书，确保浏览器能通过 HTTPS 访问资源  
**产出要求**：  
- [ ] 浏览器访问 `https://localhost:8443/hello.txt` 能正确返回内容  
- [ ] 控制台输出 HTTPS 请求的详细日志  

#### 任务13：容错处理与友好错误页面  
**场景**：处理异常和错误  
- [ ] 捕获处理过程中可能出现的异常（如文件未找到、Servlet 加载失败）  
- [ ] 提供友好的错误页面，显示错误原因和建议  
**产出要求**：  
- [ ] 返回的错误页面具有详细的错误描述和联系方式  
- [ ] 输出异常日志，便于调试和分析  

#### 任务14：集群支持
**场景**：支持多节点集群部署
- [ ] 实现节点发现和管理机制
- [ ] 实现分布式会话存储
- [ ] 实现负载均衡策略
- [ ] 实现故障检测和自动恢复
**产出要求**：
- [ ] 支持至少 2 个节点的集群部署
- [ ] 实现会话共享和故障转移
- [ ] 提供集群状态监控接口

---

### 架构完善阶段（核心概念实现）

**学习目标**：
- [ ] 实现 Pipeline-Valve 处理链机制
- [ ] 构建完整的生命周期管理体系
- [ ] 搭建标准的容器层次结构
- [ ] 实现专业的类加载体系
- [ ] 添加 JMX 管理支持
- [ ] 构建安全机制框架

#### 任务15：Pipeline-Valve 处理链实现
**场景**：灵活的请求处理链
- [x] 设计并实现 Pipeline 接口，包含 `addValve()`, `getValves()`, `invoke()` 等核心方法
- [x] 设计并实现 Valve 接口，定义 `invoke(Request, Response, ValveContext)` 方法
- [x] 实现基础阀门：AccessLogValve（访问日志）、AuthenticatorValve（认证）、StandardValve（标准处理）
- [x] 实现 StandardPipeline 作为默认实现，支持阀门的动态添加、移除和排序
**产出要求**：
- [x] 请求能够按照配置的 Valve 链依次处理
- [x] 提供示例 Valve 实现（如请求计数、访问控制）

#### 任务16：生命周期管理
**场景**：标准化组件生命周期
- [x] 实现 Lifecycle 接口，定义 BEFORE_INIT、AFTER_INIT、BEFORE_START 等标准事件
- [x] 设计 LifecycleSupport 类处理事件分发，支持同步和异步事件通知
- [x] 实现生命周期状态机，确保状态转换的正确性（如 NEW -> INITIALIZING -> INITIALIZED -> STARTING）
- [x] 为 Server、Service、Connector、Container 等核心组件添加生命周期支持
**产出要求**：
- [x] 所有核心组件支持标准生命周期管理
- [x] 生命周期事件正确触发和处理

#### 任务17：容器层次结构
**场景**：多层次容器支持
- [ ] 实现 Engine 容器：处理服务器级别的路由和配置，管理多个虚拟主机
- [ ] 实现 Host 容器：支持域名映射，管理多个 Context，配置虚拟主机级别的资源
- [ ] 实现 Context 容器：管理单个 Web 应用，包括类加载、资源访问、Session 管理
- [ ] 实现 Wrapper 容器：封装单个 Servlet 实例，处理初始化参数、过滤器链和监听器
- [ ] 实现容器事件系统，支持容器间的通信和状态同步
**产出要求**：
- [ ] 支持多虚拟主机配置和域名路由
- [ ] 请求能够正确路由到对应容器层级

#### 任务18：类加载体系
**场景**：专业的类加载器层次
- [ ] 实现 Common ClassLoader：加载共享的基础类库，作为其他类加载器的父加载器
- [ ] 实现 Catalina ClassLoader：加载服务器核心类，确保核心类的隔离
- [ ] 实现 Shared ClassLoader：加载多个应用共享的类库
- [ ] 实现 WebApp ClassLoader：为每个应用提供独立的类加载环境，支持热加载
- [ ] 实现资源定位和加载策略，支持 JAR 文件和目录的类加载
**产出要求**：
- [ ] 类加载遵循双亲委派模型，确保安全性
- [ ] 支持应用级别的类隔离和热加载

#### 任务19：JMX 管理支持
**场景**：运行时监控和管理
- [ ] 设计并实现核心组件的 MBean 接口：ServerMBean、ServiceMBean、ConnectorMBean 等
- [ ] 实现 MBeanRegistry 管理 MBean 的注册和注销
- [ ] 添加关键性能指标：请求处理时间、活动线程数、内存使用等
- [ ] 实现配置属性的动态修改和持久化
- [ ] 提供 JMX 操作接口，支持运行时重载应用、修改日志级别等
**产出要求**：
- [ ] 通过 JConsole 可以查看完整的服务器状态
- [ ] 支持运行时修改配置参数并即时生效

#### 任务20：安全框架
**场景**：用户认证和授权
- [ ] 实现 Realm 接口和主要方法：authenticate()、hasRole()、getPrincipal() 等
- [ ] 实现基于内存、文件和数据库的 Realm 实现
- [ ] 设计并实现安全约束配置，支持 URL 模式和 HTTP 方法的访问控制
- [ ] 实现基于角色的访问控制（RBAC），支持角色继承
- [ ] 添加安全拦截器，处理认证和授权逻辑
- [ ] 实现安全会话管理，支持会话固定保护和超时控制
**产出要求**：
- [ ] 支持声明式和编程式的访问控制
- [ ] 提供完整的身份认证和授权示例

---

### 附加任务（可选）

- **支持非阻塞 IO**：引入 NIO，支持更高并发处理能力  
- **性能调优**：使用简单的性能测试工具统计吞吐量和延迟（如 JMH 或自定义工具）  
- **集成 MicroSpring**：在 MicroTomcat 中运行一个简单的 Spring 应用  

通过以上任务列表，您将逐步完成从简单到复杂的 Micro Tomcat 实现，并在过程中学习核心技术点和设计模式，为深入理解 Web 服务器的实现和优化打下坚实基础。